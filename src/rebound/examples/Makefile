# -*-   mode: makefile ; coding: utf-8  -*- ------------------------------------
#
#-------------------------------------------------------------------------------

#SUBDIRS := $(filter-out shearing_sheet_mpi/. selfgravity_disc_mpi/. , $(wildcard */.)) 

#SUBDIRS_ALL := $(filter-out shearing_sheet_mpi/. selfgravity_disc_mpi/. , $(wildcard *))

SUBDIRS := J2 bouncing_balls solar_system simplest

#-------------------------------------------------------------

all: $(SUBDIRS)
	@echo ""
	@echo "SUBDIRS = $(SUBDIRS)"
	@echo ""

#-------------------------------------------------------------

clean:
	(cd J2;               make -f Make.new clean)
	@echo ""
	(cd  bouncing_balls;  make -f Make.new clean)

#-------------------------------------------------------------
$(SUBDIRS):

	@echo ""
	@echo "Trying to compile example:  $@"
	(cd $@;  make -f Make.new)

#	@echo "Trying to compile example:  $(subst /. , , $@)"
#	$(MAKE) -s -C $@ clean 
#	$(MAKE) -j -s -C $@ 
#	@echo "\033[1A\033[55CSuccess."

.PHONY: all $(SUBDIRS)

#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------

#
# http://linux.yaroslavl.ru/docs/prog/gnu_make_3-79_russian_manual.html

#-------------------------------------------------------------

# $(subst заменяемый_фрагмент, замена, текст)
#     Производит текстовую замену в тексте текст: каждой вхождение подстроки
#     заменяемый_фрагмент заменяется на фрагмент замена. Результат подставляется в
#     место вызова функции. Результатом следующего примера:

#     $(subst ee,EE,feet on the street)
    # будет строка `fEEt on the strEEt'. 

#-------------------------------------------------------------

# При использованием шаблонных символов (wildcard characters), с помощью одного имени
# можно задать целую группу файлов. В make шаблонными символами являются `*', `?' и 
# `[...]' (как в оболочке Bourne). Например, шаблон `*.c' будет соответствовать всем 
# файлам с суффиксом `.c', находящимся в текущей директории. 

# Раскрытие шаблонных имен (замена их конкретным списком файлов, удовлетворяющих 
# шаблону) автоматически производится в именах целей, именах пререквизитов и командах 
# (в командах этим занимается интерпретатор командной строки). В других случаях, 
# раскрытие шаблона производится только при явном запросе с помощью функции wildcard. 

# При задании переменной, раскрытия шаблонов не производится. Например, если вы
# запишите:
# objects = *.o
# то значением переменной objects будет строка `*.o'. Однако, если вы используете 
# значение переменной objects в цели, в пререквизите или в команде, то в момент 
# использования шаблона, будет произведено его расширение. Чтобы присвоить переменной 
# objects значение, полученное после расширения шаблона, используйте функцию wildcard:

# objects := $(wildcard *.o)

#-------------------------------------------------------------

# $(patsubst шаблон,замена,текст)
#     Находит в тексте разделенные пробелом слова, удовлетворяющие шаблону и заменяет
#     их на строку замена. Шаблон может содержать символ `%', который работает как 
#     специальный шаблонный символ, соответствующий любому количеству произвольных 
#     символов внутри слова. 

#     Пусть, например, у вас имеется список объектных файлов:
#     objects = foo.o bar.o baz.o
#     Тогда, для получения списка соответствующих исходных файлов, вы можете просто 
#     написать:
#     $(objects:.o=.c)
#     вместо того, чтобы использовать "обобщенную" форму записи:
#     $(patsubst %.o,%.c,$(objects))

#-------------------------------------------------------------

# $(filter шаблон...,текст)
#     Удаляет из текста все разделенные пробелами слова, которые не удовлетворяют ни  
#     одному из указанных шаблонов и возвращает только слова, подходящие под шаблоны.
#     Шаблоны записываются с использованием шаблонного символа `%', аналогично тому, 
#     как это делается в функции patsubst (описана выше). Функция filter может быть 
#     использована для отделения друг от друга строк (например, имен файлов) разных 
#     "типов". В следующем примере:

#     sources := foo.c bar.c baz.s ugh.h
#     foo: $(sources)
#             cc $(filter %.c %.s,$(sources)) -o foo

#     объявляется, что цель `foo' зависит от файлов `foo.c', `bar.c', `baz.s' и `ugh.h',
#     однако, при вызове компилятора, ему будут переданы только файлы `foo.c', `bar.c' 
#     и `baz.s'. 

#-------------------------------------------------------------

# $(filter-out шаблон...,текст)
#     Удаляет из текста все разделенные пробелами слова, которые соответствуют
#     какому-либо из перечисленных шаблонов, возвращая только слова, не соответствующие
#     ни одному из шаблонов. Эта функция представляет собой "противоположность"
#     функции filter.

#     Если, например, у нас имеется такой фрагмент:
#     objects=main1.o foo.o main2.o bar.o
#     mains=main1.o main2.o
#     то следующее выражение возвратит список объектных файлов, не входящих в `mains':

#$(filter-out $(mains),$(objects))

#------------------------------------------------------------------------------------
